<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: WarpExchange&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   &#160;
   <style type="text/css"> .projectnumber::after { content: "1.16.0"; } </style>
   <!--span class="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="class_warp_exchange-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">WarpExchange&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___warp_module.html">Warp-wide</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><h3>template&lt;
    typename InputT, 
    int ITEMS_PER_THREAD, 
    int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, 
    int PTX_ARCH = CUB_PTX_ARCH&gt;<br/>
class WarpExchange&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt;</h3>

<p>The <a class="el" href="class_warp_exchange.html" title="The WarpExchange class provides collective methods for rearranging data partitioned across a CUDA war...">WarpExchange</a> class provides <a href="index.html#sec0"><em>collective</em></a> methods for rearranging data partitioned across a CUDA warp. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type to be exchanged.</td></tr>
    <tr><td class="paramname">ITEMS_PER_THREAD</td><td>The number of items partitioned onto each thread.</td></tr>
    <tr><td class="paramname">LOGICAL_WARP_THREADS</td><td><b>[optional]</b> The number of threads per "logical" warp (may be less than the number of hardware warp threads). Default is the warp size of the targeted CUDA compute-capability (e.g., 32 threads for SM86). Must be a power of two.</td></tr>
    <tr><td class="paramname">PTX_ARCH</td><td><b>[optional]</b> The PTX compute capability for which to to specialize this collective, formatted as per the <code><b>CUDA_ARCH</b></code> macro (e.g., 350 for sm_35). Useful for determining the collective's storage requirements for a given device from the host. (Default: the value of <code><b>CUDA_ARCH</b></code> during the current compiler pass)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Overview</dt><dd><ul>
<li>It is commonplace for a warp of threads to rearrange data items between threads. For example, the global memory accesses prefer patterns where data items are "striped" across threads (where consecutive threads access consecutive items), yet most warp-wide operations prefer a "blocked" partitioning of items across threads (where consecutive items belong to a single thread).</li>
<li><a class="el" href="class_warp_exchange.html" title="The WarpExchange class provides collective methods for rearranging data partitioned across a CUDA war...">WarpExchange</a> supports the following types of data exchanges:<ul>
<li>Transposing between <a href="index.html#sec5sec3"><em>blocked</em></a> and <a href="index.html#sec5sec3"><em>striped</em></a> arrangements</li>
<li>Scattering ranked items to a <a href="index.html#sec5sec3"><em>striped arrangement</em></a></li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>A Simple Example</dt><dd></dd></dl>
<dl class="section user"><dt></dt><dd>The code snippet below illustrates the conversion from a "blocked" to a "striped" arrangement of 64 integer items partitioned across 16 threads where each thread owns 4 items. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/warp/warp_exchange.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(<span class="keywordtype">int</span> *d_data, ...)</div>
<div class="line">{</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warp_threads = 16;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> block_threads = 256;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> items_per_thread = 4;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warps_per_block = block_threads / warp_threads;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> warp_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(threadIdx.x) / warp_threads;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Specialize WarpExchange for a virtual warp of 16 threads owning 4 integer items each</span></div>
<div class="line">    <span class="keyword">using</span> WarpExchangeT =</div>
<div class="line">      cub::WarpExchange&lt;int, items_per_thread, warp_threads&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate shared memory for WarpExchange</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpExchangeT::TempStorage temp_storage[warps_per_block];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Load a tile of data striped across threads</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data[items_per_thread];</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Collectively exchange data into a blocked arrangement across threads</span></div>
<div class="line">    WarpExchangeT(temp_storage[warp_id]).StripedToBlocked(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of striped input <code>thread_data</code> across the block of threads is <code>{ [0,16,32,48], [1,17,33,49], ..., [15, 32, 47, 63] }</code>. The corresponding output <code>thread_data</code> in those threads will be <code>{ [0,1,2,3], [4,5,6,7], [8,9,10,11], ..., [60,61,62,63] }</code>. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_warp_exchange_1_1_temp_storage.html">TempStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations exposed by <a class="el" href="class_warp_exchange.html" title="The WarpExchange class provides collective methods for rearranging data partitioned across a CUDA war...">WarpExchange</a> require a temporary memory allocation of this nested type for thread communication. This opaque storage can be allocated directly using the <code>__shared__</code> keyword. Alternatively, it can be aliased to externally allocated memory (shared or global) or <code>union</code>'d with other storage allocation types to facilitate memory reuse.  <a href="struct_warp_exchange_1_1_temp_storage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collective constructors</div></td></tr>
<tr class="memitem:a9eca626deca9d7d6f39b6342eec88a6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eca626deca9d7d6f39b6342eec88a6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>WarpExchange</b> ()=delete</td></tr>
<tr class="separator:a9eca626deca9d7d6f39b6342eec88a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eeb62ec2c57fef36ef9c939cdd7b90c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eeb62ec2c57fef36ef9c939cdd7b90c"></a>
__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_warp_exchange.html#a8eeb62ec2c57fef36ef9c939cdd7b90c">WarpExchange</a> (<a class="el" href="struct_warp_exchange_1_1_temp_storage.html">TempStorage</a> &amp;temp_storage)</td></tr>
<tr class="memdesc:a8eeb62ec2c57fef36ef9c939cdd7b90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collective constructor using the specified memory allocation as temporary storage. <br/></td></tr>
<tr class="separator:a8eeb62ec2c57fef36ef9c939cdd7b90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data movement</div></td></tr>
<tr class="memitem:a078092b662bf8cdc67c2322d71f0a776"><td class="memTemplParams" colspan="2">template&lt;typename OutputT &gt; </td></tr>
<tr class="memitem:a078092b662bf8cdc67c2322d71f0a776"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_warp_exchange.html#a078092b662bf8cdc67c2322d71f0a776">BlockedToStriped</a> (const InputT(&amp;input_items)[ITEMS_PER_THREAD], OutputT(&amp;output_items)[ITEMS_PER_THREAD])</td></tr>
<tr class="memdesc:a078092b662bf8cdc67c2322d71f0a776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes data items from <em>blocked</em> arrangement to <em>striped</em> arrangement.  <a href="#a078092b662bf8cdc67c2322d71f0a776">More...</a><br/></td></tr>
<tr class="separator:a078092b662bf8cdc67c2322d71f0a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4c47e163886a19e1cf77983bff2369"><td class="memTemplParams" colspan="2">template&lt;typename OutputT &gt; </td></tr>
<tr class="memitem:aee4c47e163886a19e1cf77983bff2369"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_warp_exchange.html#aee4c47e163886a19e1cf77983bff2369">StripedToBlocked</a> (const InputT(&amp;input_items)[ITEMS_PER_THREAD], OutputT(&amp;output_items)[ITEMS_PER_THREAD])</td></tr>
<tr class="memdesc:aee4c47e163886a19e1cf77983bff2369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes data items from <em>striped</em> arrangement to <em>blocked</em> arrangement.  <a href="#aee4c47e163886a19e1cf77983bff2369">More...</a><br/></td></tr>
<tr class="separator:aee4c47e163886a19e1cf77983bff2369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e05362d3fe7350aa7f2a2ec16b21d97"><td class="memTemplParams" colspan="2">template&lt;typename OffsetT &gt; </td></tr>
<tr class="memitem:a5e05362d3fe7350aa7f2a2ec16b21d97"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_warp_exchange.html#a5e05362d3fe7350aa7f2a2ec16b21d97">ScatterToStriped</a> (InputT(&amp;items)[ITEMS_PER_THREAD], OffsetT(&amp;ranks)[ITEMS_PER_THREAD])</td></tr>
<tr class="memdesc:a5e05362d3fe7350aa7f2a2ec16b21d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges valid data items annotated by rank into <em>striped</em> arrangement.  <a href="#a5e05362d3fe7350aa7f2a2ec16b21d97">More...</a><br/></td></tr>
<tr class="separator:a5e05362d3fe7350aa7f2a2ec16b21d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95af44e023e98dc5c580206c6527e91"><td class="memTemplParams" colspan="2">template&lt;typename OutputT , typename OffsetT &gt; </td></tr>
<tr class="memitem:aa95af44e023e98dc5c580206c6527e91"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_warp_exchange.html#aa95af44e023e98dc5c580206c6527e91">ScatterToStriped</a> (const InputT(&amp;input_items)[ITEMS_PER_THREAD], OutputT(&amp;output_items)[ITEMS_PER_THREAD], OffsetT(&amp;ranks)[ITEMS_PER_THREAD])</td></tr>
<tr class="memdesc:aa95af44e023e98dc5c580206c6527e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges valid data items annotated by rank into <em>striped</em> arrangement.  <a href="#aa95af44e023e98dc5c580206c6527e91">More...</a><br/></td></tr>
<tr class="separator:aa95af44e023e98dc5c580206c6527e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a078092b662bf8cdc67c2322d71f0a776"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputT , int ITEMS_PER_THREAD, int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename OutputT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_warp_exchange.html">WarpExchange</a>&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::BlockedToStriped </td>
          <td>(</td>
          <td class="paramtype">const InputT(&amp;)&#160;</td>
          <td class="paramname"><em>input_items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputT(&amp;)&#160;</td>
          <td class="paramname"><em>output_items</em>[ITEMS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes data items from <em>blocked</em> arrangement to <em>striped</em> arrangement. </p>
<dl class="section user"><dt></dt><dd>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the conversion from a "blocked" to a "striped" arrangement of 64 integer items partitioned across 16 threads where each thread owns 4 items. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/warp/warp_exchange.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(<span class="keywordtype">int</span> *d_data, ...)</div>
<div class="line">{</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warp_threads = 16;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> block_threads = 256;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> items_per_thread = 4;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warps_per_block = block_threads / warp_threads;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> warp_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(threadIdx.x) / warp_threads;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Specialize WarpExchange for a virtual warp of 16 threads owning 4 integer items each</span></div>
<div class="line">    <span class="keyword">using</span> WarpExchangeT = cub::WarpExchange&lt;int, items_per_thread, warp_threads&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate shared memory for WarpExchange</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpExchangeT::TempStorage temp_storage[warps_per_block];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain a segment of consecutive items that are blocked across threads</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data[items_per_thread];</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Collectively exchange data into a striped arrangement across threads</span></div>
<div class="line">    WarpExchangeT(temp_storage[warp_id]).BlockedToStriped(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of striped input <code>thread_data</code> across the block of threads is <code>{ [0,1,2,3], [4,5,6,7], [8,9,10,11], ..., [60,61,62,63] }</code>. The corresponding output <code>thread_data</code> in those threads will be <code>{ [0,16,32,48], [1,17,33,49], ..., [15, 32, 47, 63] }</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_items</td><td>Items to exchange, converting between <em>blocked</em> and <em>striped</em> arrangements.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_items</td><td>Items from exchange, converting between <em>striped</em> and <em>blocked</em> arrangements. May be aliased to <code>input_items</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee4c47e163886a19e1cf77983bff2369"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputT , int ITEMS_PER_THREAD, int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename OutputT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_warp_exchange.html">WarpExchange</a>&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::StripedToBlocked </td>
          <td>(</td>
          <td class="paramtype">const InputT(&amp;)&#160;</td>
          <td class="paramname"><em>input_items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputT(&amp;)&#160;</td>
          <td class="paramname"><em>output_items</em>[ITEMS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes data items from <em>striped</em> arrangement to <em>blocked</em> arrangement. </p>
<dl class="section user"><dt></dt><dd>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the conversion from a "striped" to a "blocked" arrangement of 64 integer items partitioned across 16 threads where each thread owns 4 items. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/warp/warp_exchange.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(<span class="keywordtype">int</span> *d_data, ...)</div>
<div class="line">{</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warp_threads = 16;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> block_threads = 256;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> items_per_thread = 4;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warps_per_block = block_threads / warp_threads;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> warp_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(threadIdx.x) / warp_threads;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Specialize WarpExchange for a virtual warp of 16 threads owning 4 integer items each</span></div>
<div class="line">    <span class="keyword">using</span> WarpExchangeT = cub::WarpExchange&lt;int, items_per_thread, warp_threads&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate shared memory for WarpExchange</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpExchangeT::TempStorage temp_storage[warps_per_block];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Load a tile of data striped across threads</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data[items_per_thread];</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Collectively exchange data into a blocked arrangement across threads</span></div>
<div class="line">    WarpExchangeT(temp_storage[warp_id]).StripedToBlocked(thread_data, thread_data);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of striped input <code>thread_data</code> across the block of threads is <code>{ [0,16,32,48], [1,17,33,49], ..., [15, 32, 47, 63] }</code>. The corresponding output <code>thread_data</code> in those threads will be <code>{ [0,1,2,3], [4,5,6,7], [8,9,10,11], ..., [60,61,62,63] }</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_items</td><td>Items to exchange</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_items</td><td>Items from exchange. May be aliased to <code>input_items</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e05362d3fe7350aa7f2a2ec16b21d97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputT , int ITEMS_PER_THREAD, int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename OffsetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_warp_exchange.html">WarpExchange</a>&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ScatterToStriped </td>
          <td>(</td>
          <td class="paramtype">InputT(&amp;)&#160;</td>
          <td class="paramname"><em>items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetT(&amp;)&#160;</td>
          <td class="paramname"><em>ranks</em>[ITEMS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges valid data items annotated by rank into <em>striped</em> arrangement. </p>
<dl class="section user"><dt></dt><dd>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the conversion from a "scatter" to a "striped" arrangement of 64 integer items partitioned across 16 threads where each thread owns 4 items. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/warp/warp_exchange.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(<span class="keywordtype">int</span> *d_data, ...)</div>
<div class="line">{</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warp_threads = 16;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> block_threads = 256;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> items_per_thread = 4;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warps_per_block = block_threads / warp_threads;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> warp_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(threadIdx.x) / warp_threads;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Specialize WarpExchange for a virtual warp of 16 threads owning 4 integer items each</span></div>
<div class="line">    <span class="keyword">using</span> WarpExchangeT = cub::WarpExchange&lt;int, items_per_thread, warp_threads&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate shared memory for WarpExchange</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpExchangeT::TempStorage temp_storage[warps_per_block];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain a segment of consecutive items that are blocked across threads</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_data[items_per_thread];</div>
<div class="line">    <span class="keywordtype">int</span> thread_ranks[items_per_thread];</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Collectively exchange data into a striped arrangement across threads</span></div>
<div class="line">    WarpExchangeT(temp_storage[warp_id]).ScatterToStriped(</div>
<div class="line">      thread_data, thread_ranks);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_data</code> across the block of threads is <code>{ [0,1,2,3], [4,5,6,7], ..., [60,61,62,63] }</code>, and the set of <code>thread_ranks</code> is <code>{ [63,62,61,60], ..., [7,6,5,4], [3,2,1,0] }</code>. The corresponding output <code>thread_data</code> in those threads will be <code>{ [63, 47, 31, 15], [62, 46, 30, 14], ..., [48, 32, 16, 0] }</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OffsetT</td><td><b>[inferred]</b> Signed integer type for local offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">items</td><td>Items to exchange </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ranks</td><td>Corresponding scatter ranks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa95af44e023e98dc5c580206c6527e91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputT , int ITEMS_PER_THREAD, int LOGICAL_WARP_THREADS = CUB_PTX_WARP_THREADS, int PTX_ARCH = CUB_PTX_ARCH&gt; </div>
<div class="memtemplate">
template&lt;typename OutputT , typename OffsetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_warp_exchange.html">WarpExchange</a>&lt; InputT, ITEMS_PER_THREAD, LOGICAL_WARP_THREADS, PTX_ARCH &gt;::ScatterToStriped </td>
          <td>(</td>
          <td class="paramtype">const InputT(&amp;)&#160;</td>
          <td class="paramname"><em>input_items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputT(&amp;)&#160;</td>
          <td class="paramname"><em>output_items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetT(&amp;)&#160;</td>
          <td class="paramname"><em>ranks</em>[ITEMS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges valid data items annotated by rank into <em>striped</em> arrangement. </p>
<dl class="section user"><dt></dt><dd>A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the conversion from a "scatter" to a "striped" arrangement of 64 integer items partitioned across 16 threads where each thread owns 4 items. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/warp/warp_exchange.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(<span class="keywordtype">int</span> *d_data, ...)</div>
<div class="line">{</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warp_threads = 16;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> block_threads = 256;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> items_per_thread = 4;</div>
<div class="line">    constexpr <span class="keywordtype">int</span> warps_per_block = block_threads / warp_threads;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> warp_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(threadIdx.x) / warp_threads;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Specialize WarpExchange for a virtual warp of 16 threads owning 4 integer items each</span></div>
<div class="line">    <span class="keyword">using</span> WarpExchangeT = cub::WarpExchange&lt;int, items_per_thread, warp_threads&gt;;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate shared memory for WarpExchange</span></div>
<div class="line">    __shared__ <span class="keyword">typename</span> WarpExchangeT::TempStorage temp_storage[warps_per_block];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Obtain a segment of consecutive items that are blocked across threads</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_input[items_per_thread];</div>
<div class="line">    <span class="keywordtype">int</span> thread_ranks[items_per_thread];</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Collectively exchange data into a striped arrangement across threads</span></div>
<div class="line">    <span class="keywordtype">int</span> thread_output[items_per_thread];</div>
<div class="line">    WarpExchangeT(temp_storage[warp_id]).ScatterToStriped(</div>
<div class="line">      thread_input, thread_output, thread_ranks);</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>thread_input</code> across the block of threads is <code>{ [0,1,2,3], [4,5,6,7], ..., [60,61,62,63] }</code>, and the set of <code>thread_ranks</code> is <code>{ [63,62,61,60], ..., [7,6,5,4], [3,2,1,0] }</code>. The corresponding <code>thread_output</code> in those threads will be <code>{ [63, 47, 31, 15], [62, 46, 30, 14], ..., [48, 32, 16, 0] }</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OffsetT</td><td><b>[inferred]</b> Signed integer type for local offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_items</td><td>Items to exchange</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_items</td><td>Items from exchange. May be aliased to <code>input_items</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ranks</td><td>Corresponding scatter ranks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="warp__exchange_8cuh.html">warp_exchange.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2022 NVIDIA Corporation
</small></address>
</body>
</html>
