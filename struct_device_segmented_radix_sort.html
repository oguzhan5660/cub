<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: DeviceSegmentedRadixSort Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   &#160;<!--span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="struct_device_segmented_radix_sort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DeviceSegmentedRadixSort Struct Reference<div class="ingroups"><a class="el" href="group___segmented_module.html">Segmented-problem (batch)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><p><a class="el" href="struct_device_segmented_radix_sort.html" title="DeviceSegmentedRadixSort provides device-wide, parallel operations for computing a batched radix sort...">DeviceSegmentedRadixSort</a> provides device-wide, parallel operations for computing a batched radix sort across multiple, non-overlapping sequences of data items residing within device-accessible memory. </p>
<div class="image">
<img src="segmented_sorting_logo.png" alt="segmented_sorting_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>The <a href="http://en.wikipedia.org/wiki/Radix_sort"><em>radix sorting method</em></a> arranges items into ascending (or descending) order. The algorithm relies upon a positional representation for keys, i.e., each key is comprised of an ordered sequence of symbols (e.g., digits, characters, etc.) specified from least-significant to most-significant. For a given input sequence of keys and a set of rules specifying a total ordering of the symbolic alphabet, the radix sorting method produces a lexicographic ordering of those keys.</dd></dl>
<dl class="section user"><dt>See Also</dt><dd><a class="el" href="struct_device_segmented_radix_sort.html" title="DeviceSegmentedRadixSort provides device-wide, parallel operations for computing a batched radix sort...">DeviceSegmentedRadixSort</a> shares its implementation with <a class="el" href="struct_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a>. See that algorithm's documentation for more information.</dd></dl>
<dl class="section user"><dt>Usage Considerations</dt><dd><ul>
<li><em>Dynamic parallelism</em>. <a class="el" href="struct_device_segmented_radix_sort.html" title="DeviceSegmentedRadixSort provides device-wide, parallel operations for computing a batched radix sort...">DeviceSegmentedRadixSort</a> methods can be called within kernel code on devices in which CUDA dynamic parallelism is supported. </li>
</ul>
</dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Key-value pairs</div></td></tr>
<tr class="memitem:a83feb5a8b6566b32be471c4d8167c63f"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a83feb5a8b6566b32be471c4d8167c63f"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#a83feb5a8b6566b32be471c4d8167c63f">SortPairs</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a83feb5a8b6566b32be471c4d8167c63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into ascending order. (~<em>2N </em>auxiliary storage required)  <a href="#a83feb5a8b6566b32be471c4d8167c63f">More...</a><br/></td></tr>
<tr class="separator:a83feb5a8b6566b32be471c4d8167c63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe73b3b12ff221079b3b4cfcf142421"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:aafe73b3b12ff221079b3b4cfcf142421"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#aafe73b3b12ff221079b3b4cfcf142421">SortPairs</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:aafe73b3b12ff221079b3b4cfcf142421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into ascending order. (~<em>N </em>auxiliary storage required)  <a href="#aafe73b3b12ff221079b3b4cfcf142421">More...</a><br/></td></tr>
<tr class="separator:aafe73b3b12ff221079b3b4cfcf142421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf3deaa51ad24310af4a9c5ab3ae2a2"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a0bf3deaa51ad24310af4a9c5ab3ae2a2"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#a0bf3deaa51ad24310af4a9c5ab3ae2a2">SortPairsDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a0bf3deaa51ad24310af4a9c5ab3ae2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into descending order. (~<em>2N</em> auxiliary storage required).  <a href="#a0bf3deaa51ad24310af4a9c5ab3ae2a2">More...</a><br/></td></tr>
<tr class="separator:a0bf3deaa51ad24310af4a9c5ab3ae2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada42f31aa8b5e2a7f97952634e75c85e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:ada42f31aa8b5e2a7f97952634e75c85e"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#ada42f31aa8b5e2a7f97952634e75c85e">SortPairsDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ada42f31aa8b5e2a7f97952634e75c85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into descending order. (~<em>N </em>auxiliary storage required).  <a href="#ada42f31aa8b5e2a7f97952634e75c85e">More...</a><br/></td></tr>
<tr class="separator:ada42f31aa8b5e2a7f97952634e75c85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Keys-only</div></td></tr>
<tr class="memitem:af3ded5ffef2e84ae5ba6e348cf1a7240"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:af3ded5ffef2e84ae5ba6e348cf1a7240"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#af3ded5ffef2e84ae5ba6e348cf1a7240">SortKeys</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:af3ded5ffef2e84ae5ba6e348cf1a7240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into ascending order. (~<em>2N </em>auxiliary storage required)  <a href="#af3ded5ffef2e84ae5ba6e348cf1a7240">More...</a><br/></td></tr>
<tr class="separator:af3ded5ffef2e84ae5ba6e348cf1a7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a83fe568c6ff2da6cab764e1ca738c"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a46a83fe568c6ff2da6cab764e1ca738c"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#a46a83fe568c6ff2da6cab764e1ca738c">SortKeys</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a46a83fe568c6ff2da6cab764e1ca738c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into ascending order. (~<em>N </em>auxiliary storage required).  <a href="#a46a83fe568c6ff2da6cab764e1ca738c">More...</a><br/></td></tr>
<tr class="separator:a46a83fe568c6ff2da6cab764e1ca738c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba7eea7602e3183bd21753cd0b3cffc"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:abba7eea7602e3183bd21753cd0b3cffc"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#abba7eea7602e3183bd21753cd0b3cffc">SortKeysDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:abba7eea7602e3183bd21753cd0b3cffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into descending order. (~<em>2N</em> auxiliary storage required).  <a href="#abba7eea7602e3183bd21753cd0b3cffc">More...</a><br/></td></tr>
<tr class="separator:abba7eea7602e3183bd21753cd0b3cffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083cec950559a91f68f55084dc3b87d"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:ae083cec950559a91f68f55084dc3b87d"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_radix_sort.html#ae083cec950559a91f68f55084dc3b87d">SortKeysDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ae083cec950559a91f68f55084dc3b87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into descending order. (~<em>N </em>auxiliary storage required).  <a href="#ae083cec950559a91f68f55084dc3b87d">More...</a><br/></td></tr>
<tr class="separator:ae083cec950559a91f68f55084dc3b87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a83feb5a8b6566b32be471c4d8167c63f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into ascending order. (~<em>2N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [1, 2, 0, 5, 4, 3, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Device-accessible pointer to the corresponding input sequence of associated value items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Device-accessible pointer to the correspondingly-reordered output sequence of associated value items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafe73b3b12ff221079b3b4cfcf142421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into ascending order. (~<em>N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairs(d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bf3deaa51ad24310af4a9c5ab3ae2a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into descending order. (~<em>2N</em> auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [0, 2, 1, 6, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Device-accessible pointer to the corresponding input sequence of associated value items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Device-accessible pointer to the correspondingly-reordered output sequence of associated value items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada42f31aa8b5e2a7f97952634e75c85e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into descending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortPairsDescending(d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [0, 2, 1, 6, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3ded5ffef2e84ae5ba6e348cf1a7240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into ascending order. (~<em>2N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46a83fe568c6ff2da6cab764e1ca738c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into ascending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeys(d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abba7eea7602e3183bd21753cd0b3cffc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into descending order. (~<em>2N</em> auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae083cec950559a91f68f55084dc3b87d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedRadixSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into descending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When input a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_segmented_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedRadixSort::SortKeysDescending(d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type </td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type) </td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1</code> &lt;= <code>d_begin_offsets[i]</code>, the <em>i</em><sup>th</sup> is considered empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="device__segmented__radix__sort_8cuh.html">device_segmented_radix_sort.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2022 NVIDIA Corporation
</small></address>
</body>
</html>
