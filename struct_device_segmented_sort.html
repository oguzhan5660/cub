<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: DeviceSegmentedSort Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   &#160;<!--span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="struct_device_segmented_sort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DeviceSegmentedSort Struct Reference<div class="ingroups"><a class="el" href="group___segmented_module.html">Segmented-problem (batch)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><p><a class="el" href="struct_device_segmented_sort.html" title="DeviceSegmentedSort provides device-wide, parallel operations for computing a batched sort across mul...">DeviceSegmentedSort</a> provides device-wide, parallel operations for computing a batched sort across multiple, non-overlapping sequences of data items residing within device-accessible memory. </p>
<div class="image">
<img src="segmented_sorting_logo.png" alt="segmented_sorting_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>The algorithm arranges items into ascending (or descending) order. The underlying sorting algorithm is undefined. Depending on the segment size, it might be radix sort, merge sort or something else. Therefore, no assumptions on the underlying implementation should be made.</dd></dl>
<dl class="section user"><dt>Differences from DeviceSegmentedRadixSort</dt><dd><a class="el" href="struct_device_segmented_radix_sort.html" title="DeviceSegmentedRadixSort provides device-wide, parallel operations for computing a batched radix sort...">DeviceSegmentedRadixSort</a> is optimized for significantly large segments (tens of thousands of items and more). Nevertheless, some domains produce a wide range of segment sizes. <a class="el" href="struct_device_segmented_sort.html" title="DeviceSegmentedSort provides device-wide, parallel operations for computing a batched sort across mul...">DeviceSegmentedSort</a> partitions segments into size groups and specialize sorting algorithms for each group. This approach leads to better resource utilization in the presence of segment size imbalance or moderate segment sizes (up to thousands of items). This algorithm is more complex and consists of multiple kernels. This fact leads to longer compilation times as well as larger binaries sizes.</dd></dl>
<dl class="section user"><dt>Supported Types</dt><dd>The algorithm has to satisfy the underlying algorithms restrictions. Radix sort usage restricts the list of supported types. Therefore, <a class="el" href="struct_device_segmented_sort.html" title="DeviceSegmentedSort provides device-wide, parallel operations for computing a batched sort across mul...">DeviceSegmentedSort</a> can sort all of the built-in C++ numeric primitive types (<code>unsigned char</code>, <code>int</code>, <code>double</code>, etc.) as well as CUDA's <code>__half</code> and <code>__nv_bfloat16</code> 16-bit floating-point types.</dd></dl>
<dl class="section user"><dt>A simple example</dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [1, 2, 0, 5, 4, 3, 6]</span></div>
</div><!-- fragment --> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Keys-only</div></td></tr>
<tr class="memitem:ac7ab52dfd53e08d33c91ea4ae98b51a7"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:ac7ab52dfd53e08d33c91ea4ae98b51a7"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#ac7ab52dfd53e08d33c91ea4ae98b51a7">SortKeys</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ac7ab52dfd53e08d33c91ea4ae98b51a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into ascending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required.  <a href="#ac7ab52dfd53e08d33c91ea4ae98b51a7">More...</a><br/></td></tr>
<tr class="separator:ac7ab52dfd53e08d33c91ea4ae98b51a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436147441add3a931814f1bc9db6e73e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a436147441add3a931814f1bc9db6e73e"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a436147441add3a931814f1bc9db6e73e">SortKeysDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a436147441add3a931814f1bc9db6e73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into descending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required.  <a href="#a436147441add3a931814f1bc9db6e73e">More...</a><br/></td></tr>
<tr class="separator:a436147441add3a931814f1bc9db6e73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656ed5a61b7e9878ef82ade6cb1ae3e6"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a656ed5a61b7e9878ef82ade6cb1ae3e6"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a656ed5a61b7e9878ef82ade6cb1ae3e6">SortKeys</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a656ed5a61b7e9878ef82ade6cb1ae3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#a656ed5a61b7e9878ef82ade6cb1ae3e6">More...</a><br/></td></tr>
<tr class="separator:a656ed5a61b7e9878ef82ade6cb1ae3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9c9004457f9da234f879486b3ef9fd"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a5e9c9004457f9da234f879486b3ef9fd"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a5e9c9004457f9da234f879486b3ef9fd">SortKeysDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a5e9c9004457f9da234f879486b3ef9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into descending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#a5e9c9004457f9da234f879486b3ef9fd">More...</a><br/></td></tr>
<tr class="separator:a5e9c9004457f9da234f879486b3ef9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fe5ca4019bf9c9779559519d6395d4"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a61fe5ca4019bf9c9779559519d6395d4"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a61fe5ca4019bf9c9779559519d6395d4">StableSortKeys</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a61fe5ca4019bf9c9779559519d6395d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into ascending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required.  <a href="#a61fe5ca4019bf9c9779559519d6395d4">More...</a><br/></td></tr>
<tr class="separator:a61fe5ca4019bf9c9779559519d6395d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf658f12f48424c40bfc9f384737a48c"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:aaf658f12f48424c40bfc9f384737a48c"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#aaf658f12f48424c40bfc9f384737a48c">StableSortKeysDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:aaf658f12f48424c40bfc9f384737a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into descending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required.  <a href="#aaf658f12f48424c40bfc9f384737a48c">More...</a><br/></td></tr>
<tr class="separator:aaf658f12f48424c40bfc9f384737a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce898426f85b491b8cbd5384720548c"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a5ce898426f85b491b8cbd5384720548c"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a5ce898426f85b491b8cbd5384720548c">StableSortKeys</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a5ce898426f85b491b8cbd5384720548c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#a5ce898426f85b491b8cbd5384720548c">More...</a><br/></td></tr>
<tr class="separator:a5ce898426f85b491b8cbd5384720548c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddfce66c489bda43298c4fbcb7ba02a"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:adddfce66c489bda43298c4fbcb7ba02a"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#adddfce66c489bda43298c4fbcb7ba02a">StableSortKeysDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:adddfce66c489bda43298c4fbcb7ba02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of keys into descending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#adddfce66c489bda43298c4fbcb7ba02a">More...</a><br/></td></tr>
<tr class="separator:adddfce66c489bda43298c4fbcb7ba02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Key-value pairs</div></td></tr>
<tr class="memitem:a4093ad10868441622bae9bc7668abe2c"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a4093ad10868441622bae9bc7668abe2c"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a4093ad10868441622bae9bc7668abe2c">SortPairs</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a4093ad10868441622bae9bc7668abe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required.  <a href="#a4093ad10868441622bae9bc7668abe2c">More...</a><br/></td></tr>
<tr class="separator:a4093ad10868441622bae9bc7668abe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910b9eda03d53139ad96e073fc7dacb3"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a910b9eda03d53139ad96e073fc7dacb3"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a910b9eda03d53139ad96e073fc7dacb3">SortPairsDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a910b9eda03d53139ad96e073fc7dacb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into descending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required.  <a href="#a910b9eda03d53139ad96e073fc7dacb3">More...</a><br/></td></tr>
<tr class="separator:a910b9eda03d53139ad96e073fc7dacb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8f181a9021f1af845e5fd26f25e488"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a2f8f181a9021f1af845e5fd26f25e488"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a2f8f181a9021f1af845e5fd26f25e488">SortPairs</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a2f8f181a9021f1af845e5fd26f25e488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#a2f8f181a9021f1af845e5fd26f25e488">More...</a><br/></td></tr>
<tr class="separator:a2f8f181a9021f1af845e5fd26f25e488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf7e2ec0a1cb607693a37708e178412"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a4bf7e2ec0a1cb607693a37708e178412"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a4bf7e2ec0a1cb607693a37708e178412">SortPairsDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a4bf7e2ec0a1cb607693a37708e178412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into descending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#a4bf7e2ec0a1cb607693a37708e178412">More...</a><br/></td></tr>
<tr class="separator:a4bf7e2ec0a1cb607693a37708e178412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac939dd91f2a69694653740e9b5ba619"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:aac939dd91f2a69694653740e9b5ba619"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#aac939dd91f2a69694653740e9b5ba619">StableSortPairs</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:aac939dd91f2a69694653740e9b5ba619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required.  <a href="#aac939dd91f2a69694653740e9b5ba619">More...</a><br/></td></tr>
<tr class="separator:aac939dd91f2a69694653740e9b5ba619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9827c6c2370d039d8cde6ccc75b8f6"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:a6e9827c6c2370d039d8cde6ccc75b8f6"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#a6e9827c6c2370d039d8cde6ccc75b8f6">StableSortPairsDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a6e9827c6c2370d039d8cde6ccc75b8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into descending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required.  <a href="#a6e9827c6c2370d039d8cde6ccc75b8f6">More...</a><br/></td></tr>
<tr class="separator:a6e9827c6c2370d039d8cde6ccc75b8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42166b2938827b5d544496b16ee3849"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:ac42166b2938827b5d544496b16ee3849"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#ac42166b2938827b5d544496b16ee3849">StableSortPairs</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ac42166b2938827b5d544496b16ee3849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#ac42166b2938827b5d544496b16ee3849">More...</a><br/></td></tr>
<tr class="separator:ac42166b2938827b5d544496b16ee3849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c7789ee54719452cb7f2edece3801"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </td></tr>
<tr class="memitem:afb0c7789ee54719452cb7f2edece3801"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_device_segmented_sort.html#afb0c7789ee54719452cb7f2edece3801">StableSortPairsDescending</a> (void *d_temp_storage, std::size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int num_segments, BeginOffsetIteratorT d_begin_offsets, EndOffsetIteratorT d_end_offsets, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:afb0c7789ee54719452cb7f2edece3801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts segments of key-value pairs into descending order. Approximately <code>2*num_segments</code> auxiliary storage required.  <a href="#afb0c7789ee54719452cb7f2edece3801">More...</a><br/></td></tr>
<tr class="separator:afb0c7789ee54719452cb7f2edece3801"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac7ab52dfd53e08d33c91ea4ae98b51a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into ascending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>SortKeys is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible</span></div>
<div class="line"><span class="comment">// pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void    *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i] - 1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i] - 1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a436147441add3a931814f1bc9db6e73e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into descending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments + 1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets + 1</code>).</li>
<li>SortKeysDescending is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void    *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i] - 1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i] - 1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a656ed5a61b7e9878ef82ade6cb1ae3e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>SortKeys is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible</span></div>
<div class="line"><span class="comment">// pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i] - 1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i] - 1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e9c9004457f9da234f879486b3ef9fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into descending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments + 1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets + 1</code>).</li>
<li>SortKeysDescending is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for</span></div>
<div class="line"><span class="comment">// sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When <code>nullptr</code>, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i] - 1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i] - 1&lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61fe5ca4019bf9c9779559519d6395d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into ascending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortKeys is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void    *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf658f12f48424c40bfc9f384737a48c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into descending order. Approximately <code>num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortKeysDescending is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void    *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ce898426f85b491b8cbd5384720548c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortKeys is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeys(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i] - 1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i] - 1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adddfce66c489bda43298c4fbcb7ba02a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of keys into descending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortKeysDescending is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortKeysDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4093ad10868441622bae9bc7668abe2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>SortPairs is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [1, 2, 0, 5, 4, 3, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When <code>nullptr</code>, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Device-accessible pointer to the corresponding input sequence of associated value items</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Device-accessible pointer to the correspondingly-reordered output sequence of associated value items</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a910b9eda03d53139ad96e073fc7dacb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into descending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>SortPairs is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for</span></div>
<div class="line"><span class="comment">// sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void    *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [0, 2, 1, 6, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Device-accessible pointer to the corresponding input sequence of associated value items</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Device-accessible pointer to the correspondingly-reordered output sequence of associated value items</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f8f181a9021f1af845e5fd26f25e488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>SortPairs is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When <code>nullptr</code>, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4bf7e2ec0a1cb607693a37708e178412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into descending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>SortPairsDescending is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for</span></div>
<div class="line"><span class="comment">// sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::SortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::SortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [0, 2, 1, 6, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac939dd91f2a69694653740e9b5ba619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortPairs is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [1, 2, 0, 5, 4, 3, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When nullptr, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Device-accessible pointer to the corresponding input sequence of associated value items</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Device-accessible pointer to the correspondingly-reordered output sequence of associated value items</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e9827c6c2370d039d8cde6ccc75b8f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into descending order. Approximately <code>2*num_items + 2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortPairsDescending is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [0, 2, 1, 6, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When <code>nullptr</code>, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Device-accessible pointer to the input data of key data to sort</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Device-accessible pointer to the sorted output sequence of key data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Device-accessible pointer to the corresponding input sequence of associated value items</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Device-accessible pointer to the correspondingly-reordered output sequence of associated value items</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac42166b2938827b5d544496b16ee3849"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into ascending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortPairs is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairs(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [6, 7, 8, 0, 3, 5, 9]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When <code>nullptr</code>, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb0c7789ee54719452cb7f2edece3801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename BeginOffsetIteratorT , typename EndOffsetIteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t DeviceSegmentedSort::StableSortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BeginOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndOffsetIteratorT&#160;</td>
          <td class="paramname"><em>d_end_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts segments of key-value pairs into descending order. Approximately <code>2*num_segments</code> auxiliary storage required. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>When the input is a contiguous sequence of segments, a single sequence <code>segment_offsets</code> (of length <code>num_segments+1</code>) can be aliased for both the <code>d_begin_offsets</code> and <code>d_end_offsets</code> parameters (where the latter is specified as <code>segment_offsets+1</code>).</li>
<li>StableSortPairsDescending is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x</code> &lt; <code>y</code> nor <code>y</code> &lt; <code>x</code>) then a postcondition of stable sort is that <code>x</code> still precedes <code>y</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the batched sorting of three segments (with one zero-length segment) of <code>int</code> keys with associated vector of <code>int</code> values.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span></div>
<div class="line"><span class="comment">// or equivalently &lt;cub/device/device_segmented_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers</span></div>
<div class="line"><span class="comment">// for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  num_segments;       <span class="comment">// e.g., 3</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_offsets;         <span class="comment">// e.g., [0, 3, 3, 7]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [-, -, -, -, -, -, -]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line">cub::DeviceSegmentedSort::StableSortPairsDescending(</div>
<div class="line">    d_temp_storage, temp_storage_bytes, d_keys, d_values,</div>
<div class="line">    num_items, num_segments, d_offsets, d_offsets + 1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [8, 7, 6, 9, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [0, 2, 1, 6, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> Key type</td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> Value type</td></tr>
    <tr><td class="paramname">BeginOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment beginning offsets (may be a simple pointer type)</td></tr>
    <tr><td class="paramname">EndOffsetIteratorT</td><td><b>[inferred]</b> Random-access input iterator type for reading segment ending offsets (may be a simple pointer type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When <code>nullptr</code>, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>The total number of items to sort (across all segments)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_segments</td><td>The number of segments that comprise the sorting data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_begin_offsets</td><td>Random-access input iterator to the sequence of beginning offsets of length <code>num_segments</code>, such that <code>d_begin_offsets[i]</code> is the first element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_end_offsets</td><td>Random-access input iterator to the sequence of ending offsets of length <code>num_segments</code>, such that <code>d_end_offsets[i]-1</code> is the last element of the <em>i</em><sup>th</sup> data segment in <code>d_keys_*</code> and <code>d_values_*</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> <code>d_end_offsets[i]-1 &lt;= d_begin_offsets[i]</code>, the i-th segment is considered empty.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="device__segmented__sort_8cuh.html">device_segmented_sort.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2022 NVIDIA Corporation
</small></address>
</body>
</html>
