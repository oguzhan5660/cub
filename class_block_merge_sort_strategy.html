<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: BlockMergeSortStrategy&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   &#160;
   <style type="text/css"> .projectnumber::after { content: "1.16.0"; } </style>
   <span class="projectnumber" id='projectnumber' style="display:none">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="class_block_merge_sort_strategy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockMergeSortStrategy&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><h3>template&lt;
    typename KeyT, 
    typename ValueT, 
    int NUM_THREADS, 
    int ITEMS_PER_THREAD, 
    typename SynchronizationPolicy&gt;<br/>
class BlockMergeSortStrategy&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;</h3>

<p>Generalized merge sort algorithm. </p>
<p>This class is used to reduce code duplication. Warp and Block merge sort differ only in how they compute thread index and how they synchronize threads. Since synchronization might require access to custom data (like member mask), CRTP is used.</p>
<dl class="section user"><dt></dt><dd>The code snippet below illustrates the way this class can be used. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span> <span class="comment">// or equivalently &lt;cub/block/block_merge_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line">constexpr <span class="keywordtype">int</span> BLOCK_THREADS = 256;</div>
<div class="line">constexpr <span class="keywordtype">int</span> ITEMS_PER_THREAD = 9;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>BlockMergeSort : <span class="keyword">public</span> <a class="code" href="class_block_merge_sort_strategy.html" title="Generalized merge sort algorithm. ">BlockMergeSortStrategy</a>&lt;int,</div>
<div class="line">                                                     cub::NullType,</div>
<div class="line">                                                     BLOCK_THREADS,</div>
<div class="line">                                                     ITEMS_PER_THREAD,</div>
<div class="line">                                                     BlockMergeSort&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> BlockMergeSortStrategyT =</div>
<div class="line">    <a class="code" href="class_block_merge_sort_strategy.html" title="Generalized merge sort algorithm. ">BlockMergeSortStrategy</a>&lt;int,</div>
<div class="line">                           cub::NullType,</div>
<div class="line">                           BLOCK_THREADS,</div>
<div class="line">                           ITEMS_PER_THREAD,</div>
<div class="line">                           BlockMergeSort&gt;;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  __device__ __forceinline__ <span class="keyword">explicit</span> BlockMergeSort(</div>
<div class="line">    <span class="keyword">typename</span> BlockMergeSortStrategyT::TempStorage &amp;temp_storage)</div>
<div class="line">      : BlockMergeSortStrategyT(temp_storage, threadIdx.x)</div>
<div class="line">  {}</div>
<div class="line"></div>
<div class="line">  __device__ __forceinline__ <span class="keywordtype">void</span> SyncImplementation()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    __syncthreads();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td>KeyT type</td></tr>
    <tr><td class="paramname">ValueT</td><td>ValueT type. cub::NullType indicates a keys-only sort</td></tr>
    <tr><td class="paramname">SynchronizationPolicy</td><td>Provides a way of synchronizing threads. Should be derived from <code><a class="el" href="class_block_merge_sort_strategy.html" title="Generalized merge sort algorithm. ">BlockMergeSortStrategy</a></code>. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_block_merge_sort_strategy_1_1_temp_storage.html">TempStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operations exposed by <a class="el" href="class_block_merge_sort.html" title="The BlockMergeSort class provides methods for sorting items partitioned across a CUDA thread block us...">BlockMergeSort</a> require a temporary memory allocation of this nested type for thread communication. This opaque storage can be allocated directly using the <code>__shared__</code> keyword. Alternatively, it can be aliased to externally allocated memory (shared or global) or <code>union</code>'d with other storage allocation types to facilitate memory reuse.  <a href="struct_block_merge_sort_strategy_1_1_temp_storage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:a8ef8a7a07e5af8997d155d60f976fad4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#a8ef8a7a07e5af8997d155d60f976fad4">BlockMergeSortStrategy</a> ()=delete</td></tr>
<tr class="separator:a8ef8a7a07e5af8997d155d60f976fad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d100a9d672c4cfc8d71bab59e4568d"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#a38d100a9d672c4cfc8d71bab59e4568d">BlockMergeSortStrategy</a> (unsigned int linear_tid)</td></tr>
<tr class="separator:a38d100a9d672c4cfc8d71bab59e4568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40dc2bc28ba6c90b7440f9a0c4215a3"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#ab40dc2bc28ba6c90b7440f9a0c4215a3">BlockMergeSortStrategy</a> (<a class="el" href="struct_block_merge_sort_strategy_1_1_temp_storage.html">TempStorage</a> &amp;temp_storage, unsigned int linear_tid)</td></tr>
<tr class="separator:ab40dc2bc28ba6c90b7440f9a0c4215a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bf219a4fe2fe33f1a727885e6387e7"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ <br class="typebreak"/>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#ac4bf219a4fe2fe33f1a727885e6387e7">get_linear_tid</a> () const </td></tr>
<tr class="separator:ac4bf219a4fe2fe33f1a727885e6387e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05b8bcab598b7782043728d266c5e74"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp &gt; </td></tr>
<tr class="memitem:ae05b8bcab598b7782043728d266c5e74"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#ae05b8bcab598b7782043728d266c5e74">Sort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], CompareOp compare_op)</td></tr>
<tr class="memdesc:ae05b8bcab598b7782043728d266c5e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#ae05b8bcab598b7782043728d266c5e74">More...</a><br/></td></tr>
<tr class="separator:ae05b8bcab598b7782043728d266c5e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f6fedeb7fab744c33b96246db95ff3"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp &gt; </td></tr>
<tr class="memitem:a36f6fedeb7fab744c33b96246db95ff3"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#a36f6fedeb7fab744c33b96246db95ff3">Sort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], CompareOp compare_op, int valid_items, KeyT oob_default)</td></tr>
<tr class="memdesc:a36f6fedeb7fab744c33b96246db95ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#a36f6fedeb7fab744c33b96246db95ff3">More...</a><br/></td></tr>
<tr class="separator:a36f6fedeb7fab744c33b96246db95ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc3cfb9f36f3cc2e71b587e5cc1df6"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp &gt; </td></tr>
<tr class="memitem:a23cc3cfb9f36f3cc2e71b587e5cc1df6"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#a23cc3cfb9f36f3cc2e71b587e5cc1df6">Sort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], ValueT(&amp;items)[ITEMS_PER_THREAD], CompareOp compare_op)</td></tr>
<tr class="memdesc:a23cc3cfb9f36f3cc2e71b587e5cc1df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#a23cc3cfb9f36f3cc2e71b587e5cc1df6">More...</a><br/></td></tr>
<tr class="separator:a23cc3cfb9f36f3cc2e71b587e5cc1df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a4cadbecc3883fe4914ba9bcb5fdb3"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp , bool IS_LAST_TILE = true&gt; </td></tr>
<tr class="memitem:a41a4cadbecc3883fe4914ba9bcb5fdb3"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#a41a4cadbecc3883fe4914ba9bcb5fdb3">Sort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], ValueT(&amp;items)[ITEMS_PER_THREAD], CompareOp compare_op, int valid_items, KeyT oob_default)</td></tr>
<tr class="memdesc:a41a4cadbecc3883fe4914ba9bcb5fdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#a41a4cadbecc3883fe4914ba9bcb5fdb3">More...</a><br/></td></tr>
<tr class="separator:a41a4cadbecc3883fe4914ba9bcb5fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb162397cf7f126d303bdd6298992df"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp &gt; </td></tr>
<tr class="memitem:a7eb162397cf7f126d303bdd6298992df"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#a7eb162397cf7f126d303bdd6298992df">StableSort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], CompareOp compare_op)</td></tr>
<tr class="memdesc:a7eb162397cf7f126d303bdd6298992df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#a7eb162397cf7f126d303bdd6298992df">More...</a><br/></td></tr>
<tr class="separator:a7eb162397cf7f126d303bdd6298992df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76fa43e7e64ad7b0236042eb60e3881"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp &gt; </td></tr>
<tr class="memitem:ad76fa43e7e64ad7b0236042eb60e3881"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#ad76fa43e7e64ad7b0236042eb60e3881">StableSort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], ValueT(&amp;items)[ITEMS_PER_THREAD], CompareOp compare_op)</td></tr>
<tr class="memdesc:ad76fa43e7e64ad7b0236042eb60e3881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#ad76fa43e7e64ad7b0236042eb60e3881">More...</a><br/></td></tr>
<tr class="separator:ad76fa43e7e64ad7b0236042eb60e3881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48a36abbad3dbca866aa62f7fdd4d4c"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp &gt; </td></tr>
<tr class="memitem:aa48a36abbad3dbca866aa62f7fdd4d4c"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#aa48a36abbad3dbca866aa62f7fdd4d4c">StableSort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], CompareOp compare_op, int valid_items, KeyT oob_default)</td></tr>
<tr class="memdesc:aa48a36abbad3dbca866aa62f7fdd4d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#aa48a36abbad3dbca866aa62f7fdd4d4c">More...</a><br/></td></tr>
<tr class="separator:aa48a36abbad3dbca866aa62f7fdd4d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84c08b728c79e690a90ff6e83f249fc"><td class="memTemplParams" colspan="2">template&lt;typename CompareOp , bool IS_LAST_TILE = true&gt; </td></tr>
<tr class="memitem:ae84c08b728c79e690a90ff6e83f249fc"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_block_merge_sort_strategy.html#ae84c08b728c79e690a90ff6e83f249fc">StableSort</a> (KeyT(&amp;keys)[ITEMS_PER_THREAD], ValueT(&amp;items)[ITEMS_PER_THREAD], CompareOp compare_op, int valid_items, KeyT oob_default)</td></tr>
<tr class="memdesc:ae84c08b728c79e690a90ff6e83f249fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts items partitioned across a CUDA thread block using a merge sorting method.  <a href="#ae84c08b728c79e690a90ff6e83f249fc">More...</a><br/></td></tr>
<tr class="separator:ae84c08b728c79e690a90ff6e83f249fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8ef8a7a07e5af8997d155d60f976fad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::<a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38d100a9d672c4cfc8d71bab59e4568d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::<a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>linear_tid</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab40dc2bc28ba6c90b7440f9a0c4215a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::<a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_block_merge_sort_strategy_1_1_temp_storage.html">TempStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>linear_tid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac4bf219a4fe2fe33f1a727885e6387e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ unsigned int <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::get_linear_tid </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae05b8bcab598b7782043728d266c5e74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd>Sort is not guaranteed to be stable. That is, suppose that i and j are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36f6fedeb7fab744c33b96246db95ff3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valid_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT&#160;</td>
          <td class="paramname"><em>oob_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>Sort is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
<li>The value of <code>oob_default</code> is assigned to all elements that are out of <code>valid_items</code> boundaries. It's expected that <code>oob_default</code> is ordered after any value in the <code>valid_items</code> boundaries. The algorithm always sorts a fixed amount of elements, which is equal to <code>ITEMS_PER_THREAD * BLOCK_THREADS</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> there is a value that is ordered after <code>oob_default</code>, it won't be placed within <code>valid_items</code> boundaries.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid_items</td><td>Number of valid items to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oob_default</td><td>Default value to assign out-of-bound items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23cc3cfb9f36f3cc2e71b587e5cc1df6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT(&amp;)&#160;</td>
          <td class="paramname"><em>items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd>Sort is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">items</td><td>Values to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41a4cadbecc3883fe4914ba9bcb5fdb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp , bool IS_LAST_TILE = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::Sort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT(&amp;)&#160;</td>
          <td class="paramname"><em>items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valid_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT&#160;</td>
          <td class="paramname"><em>oob_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>Sort is not guaranteed to be stable. That is, suppose that <code>i</code> and <code>j</code> are equivalent: neither one is less than the other. It is not guaranteed that the relative order of these two elements will be preserved by sort.</li>
<li>The value of <code>oob_default</code> is assigned to all elements that are out of <code>valid_items</code> boundaries. It's expected that <code>oob_default</code> is ordered after any value in the <code>valid_items</code> boundaries. The algorithm always sorts a fixed amount of elements, which is equal to <code>ITEMS_PER_THREAD * BLOCK_THREADS</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> there is a value that is ordered after <code>oob_default</code>, it won't be placed within <code>valid_items</code> boundaries.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code> <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
    <tr><td class="paramname">IS_LAST_TILE</td><td>True if <code>valid_items</code> isn't equal to the <code>ITEMS_PER_TILE</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">items</td><td>Values to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid_items</td><td>Number of valid items to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oob_default</td><td>Default value to assign out-of-bound items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7eb162397cf7f126d303bdd6298992df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::StableSort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd>StableSort is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of StableSort is that <code>x</code> still precedes <code>y</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad76fa43e7e64ad7b0236042eb60e3881"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::StableSort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT(&amp;)&#160;</td>
          <td class="paramname"><em>items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd>StableSort is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of StableSort is that <code>x</code> still precedes <code>y</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">items</td><td>Values to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa48a36abbad3dbca866aa62f7fdd4d4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::StableSort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valid_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT&#160;</td>
          <td class="paramname"><em>oob_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>StableSort is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of StableSort is that <code>x</code> still precedes <code>y</code>.</li>
<li>The value of <code>oob_default</code> is assigned to all elements that are out of <code>valid_items</code> boundaries. It's expected that <code>oob_default</code> is ordered after any value in the <code>valid_items</code> boundaries. The algorithm always sorts a fixed amount of elements, which is equal to <code>ITEMS_PER_THREAD * BLOCK_THREADS</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> there is a value that is ordered after <code>oob_default</code>, it won't be placed within <code>valid_items</code> boundaries.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid_items</td><td>Number of valid items to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oob_default</td><td>Default value to assign out-of-bound items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae84c08b728c79e690a90ff6e83f249fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT, typename ValueT, int NUM_THREADS, int ITEMS_PER_THREAD, typename SynchronizationPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename CompareOp , bool IS_LAST_TILE = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="class_block_merge_sort_strategy.html">BlockMergeSortStrategy</a>&lt; KeyT, ValueT, NUM_THREADS, ITEMS_PER_THREAD, SynchronizationPolicy &gt;::StableSort </td>
          <td>(</td>
          <td class="paramtype">KeyT(&amp;)&#160;</td>
          <td class="paramname"><em>keys</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT(&amp;)&#160;</td>
          <td class="paramname"><em>items</em>[ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompareOp&#160;</td>
          <td class="paramname"><em>compare_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valid_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT&#160;</td>
          <td class="paramname"><em>oob_default</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts items partitioned across a CUDA thread block using a merge sorting method. </p>
<dl class="section user"><dt></dt><dd><ul>
<li>StableSort is stable: it preserves the relative ordering of equivalent elements. That is, if <code>x</code> and <code>y</code> are elements such that <code>x</code> precedes <code>y</code>, and if the two elements are equivalent (neither <code>x &lt; y</code> nor <code>y &lt; x</code>) then a postcondition of StableSort is that <code>x</code> still precedes <code>y</code>.</li>
<li>The value of <code>oob_default</code> is assigned to all elements that are out of <code>valid_items</code> boundaries. It's expected that <code>oob_default</code> is ordered after any value in the <code>valid_items</code> boundaries. The algorithm always sorts a fixed amount of elements, which is equal to <code>ITEMS_PER_THREAD * BLOCK_THREADS</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> there is a value that is ordered after <code>oob_default</code>, it won't be placed within <code>valid_items</code> boundaries.</li>
</ul>
</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CompareOp</td><td>functor type having member <code>bool operator()(KeyT lhs, KeyT rhs)</code>. <code>CompareOp</code> is a model of [Strict Weak Ordering].</td></tr>
    <tr><td class="paramname">IS_LAST_TILE</td><td>True if <code>valid_items</code> isn't equal to the <code>ITEMS_PER_TILE</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to sort</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">items</td><td>Values to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare_op</td><td>Comparison function object which returns true if the first argument is ordered before the second</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valid_items</td><td>Number of valid items to sort</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oob_default</td><td>Default value to assign out-of-bound items </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="block__merge__sort_8cuh.html">block_merge_sort.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2022 NVIDIA Corporation
</small></address>
</body>
</html>
