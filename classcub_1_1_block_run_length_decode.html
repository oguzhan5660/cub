<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: cub::BlockRunLengthDecode&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   &#160;
   <style type="text/css"> .projectnumber::after { content: "1.16.0"; } </style>
   <span class="projectnumber" id='projectnumber' style="display:none">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="classcub_1_1_block_run_length_decode.html">BlockRunLengthDecode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Methods</a> &#124;
<a href="classcub_1_1_block_run_length_decode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::BlockRunLengthDecode&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><h3>template&lt;
    typename ItemT, 
    int BLOCK_DIM_X, 
    int RUNS_PER_THREAD, 
    int DECODED_ITEMS_PER_THREAD, 
    typename DecodedOffsetT = uint32_t, 
    int BLOCK_DIM_Y = 1, 
    int BLOCK_DIM_Z = 1&gt;<br/>
class cub::BlockRunLengthDecode&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;</h3>

<p>The <a class="el" href="classcub_1_1_block_run_length_decode.html" title="The BlockRunLengthDecode class supports decoding a run-length encoded array of items. That is, given the two arrays run_value[N] and run_lengths[N], run_value[i] is repeated run_lengths[i] many times in the output array. Due to the nature of the run-length decoding algorithm (&quot;decompression&quot;), the output size of the run-length decoded array is runtime-dependent and potentially without any upper bound. To address this, BlockRunLengthDecode allows retrieving a &quot;window&quot; from the run-length decoded array. The window&#39;s offset can be specified and BLOCK_THREADS * DECODED_ITEMS_PER_THREAD (i.e., referred to as window_size) decoded items from the specified window will be returned. ">BlockRunLengthDecode</a> class supports decoding a run-length encoded array of items. That is, given the two arrays run_value[N] and run_lengths[N], run_value[i] is repeated run_lengths[i] many times in the output array. Due to the nature of the run-length decoding algorithm ("decompression"), the output size of the run-length decoded array is runtime-dependent and potentially without any upper bound. To address this, <a class="el" href="classcub_1_1_block_run_length_decode.html" title="The BlockRunLengthDecode class supports decoding a run-length encoded array of items. That is, given the two arrays run_value[N] and run_lengths[N], run_value[i] is repeated run_lengths[i] many times in the output array. Due to the nature of the run-length decoding algorithm (&quot;decompression&quot;), the output size of the run-length decoded array is runtime-dependent and potentially without any upper bound. To address this, BlockRunLengthDecode allows retrieving a &quot;window&quot; from the run-length decoded array. The window&#39;s offset can be specified and BLOCK_THREADS * DECODED_ITEMS_PER_THREAD (i.e., referred to as window_size) decoded items from the specified window will be returned. ">BlockRunLengthDecode</a> allows retrieving a "window" from the run-length decoded array. The window's offset can be specified and BLOCK_THREADS * DECODED_ITEMS_PER_THREAD (i.e., referred to as window_size) decoded items from the specified window will be returned. </p>
<dl class="section note"><dt>Note</dt><dd>: Trailing runs of length 0 are supported (i.e., they may only appear at the end of the run_lengths array). A run of length zero may not be followed by a run length that is not zero.</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">__global__ <span class="keywordtype">void</span> ExampleKernel(...)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Specialising BlockRunLengthDecode to run-length decode items of type uint64_t</span></div>
<div class="line">  <span class="keyword">using</span> RunItemT = uint64_t;</div>
<div class="line">  <span class="comment">// Type large enough to index into the run-length decoded array</span></div>
<div class="line">  <span class="keyword">using</span> RunLengthT = uint32_t;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Specialising BlockRunLengthDecode for a 1D block of 128 threads</span></div>
<div class="line">  constexpr <span class="keywordtype">int</span> BLOCK_DIM_X = 128;</div>
<div class="line">  <span class="comment">// Specialising BlockRunLengthDecode to have each thread contribute 2 run-length encoded runs</span></div>
<div class="line">  constexpr <span class="keywordtype">int</span> RUNS_PER_THREAD = 2;</div>
<div class="line">  <span class="comment">// Specialising BlockRunLengthDecode to have each thread hold 4 run-length decoded items</span></div>
<div class="line">  constexpr <span class="keywordtype">int</span> DECODED_ITEMS_PER_THREAD = 4;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Specialize BlockRadixSort for a 1D block of 128 threads owning 4 integer items each</span></div>
<div class="line">  <span class="keyword">using</span> BlockRunLengthDecodeT =</div>
<div class="line">    <a class="code" href="classcub_1_1_block_run_length_decode.html" title="The BlockRunLengthDecode class supports decoding a run-length encoded array of items. That is, given the two arrays run_value[N] and run_lengths[N], run_value[i] is repeated run_lengths[i] many times in the output array. Due to the nature of the run-length decoding algorithm (&quot;decompression&quot;), the output size of the run-length decoded array is runtime-dependent and potentially without any upper bound. To address this, BlockRunLengthDecode allows retrieving a &quot;window&quot; from the run-length decoded array. The window&#39;s offset can be specified and BLOCK_THREADS * DECODED_ITEMS_PER_THREAD (i.e., referred to as window_size) decoded items from the specified window will be returned. ">cub::BlockRunLengthDecode&lt;RunItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD&gt;</a>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Allocate shared memory for BlockRunLengthDecode</span></div>
<div class="line">  __shared__ <span class="keyword">typename</span> BlockRunLengthDecodeT::TempStorage temp_storage;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// The run-length encoded items and how often they shall be repeated in the run-length decoded output</span></div>
<div class="line">  RunItemT run_values[RUNS_PER_THREAD];</div>
<div class="line">  RunLengthT run_lengths[RUNS_PER_THREAD];</div>
<div class="line">  ...</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize the BlockRunLengthDecode with the runs that we want to run-length decode</span></div>
<div class="line">  uint32_t total_decoded_size = 0;</div>
<div class="line">  BlockRunLengthDecodeT block_rld(temp_storage, run_values, run_lengths, total_decoded_size);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Run-length decode (&quot;decompress&quot;) the runs into a window buffer of limited size. This is repeated until all runs</span></div>
<div class="line">  <span class="comment">// have been decoded.</span></div>
<div class="line">  uint32_t decoded_window_offset = 0U;</div>
<div class="line">  <span class="keywordflow">while</span> (decoded_window_offset &lt; total_decoded_size)</div>
<div class="line">  {</div>
<div class="line">    RunLengthT relative_offsets[DECODED_ITEMS_PER_THREAD];</div>
<div class="line">    RunItemT decoded_items[DECODED_ITEMS_PER_THREAD];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The number of decoded items that are valid within this window (aka pass) of run-length decoding</span></div>
<div class="line">    uint32_t num_valid_items = total_decoded_size - decoded_window_offset;</div>
<div class="line">    block_rld.RunLengthDecode(decoded_items, relative_offsets, decoded_window_offset);</div>
<div class="line"></div>
<div class="line">    decoded_window_offset += BLOCK_DIM_X * DECODED_ITEMS_PER_THREAD;</div>
<div class="line"></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Suppose the set of input <code>run_values</code> across the block of threads is <code>{ [0, 1], [2, 3], [4, 5], [6, 7], ..., [254, 255] }</code> and <code>run_lengths</code> is <code>{ [1, 2], [3, 4], [5, 1], [2, 3], ..., [5, 1] }</code>. The corresponding output <code>decoded_items</code> in those threads will be <code>{ [0, 1, 1, 2], [2, 2, 3, 3], [3, 3, 4, 4], [4, 4, 4, 5], ..., [169, 169, 170, 171] }</code> and <code>relative_offsets</code> will be <code>{ [0, 0, 1, 0], [1, 2, 0, 1], [2, 3, 0, 1], [2, 3, 4, 0], ..., [3, 4, 0, 0] }</code> during the first iteration of the while loop.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ItemT</td><td>The data type of the items being run-length decoded </td></tr>
    <tr><td class="paramname">BLOCK_DIM_X</td><td>The thread block length in threads along the X dimension </td></tr>
    <tr><td class="paramname">RUNS_PER_THREAD</td><td>The number of consecutive runs that each thread contributes </td></tr>
    <tr><td class="paramname">DECODED_ITEMS_PER_THREAD</td><td>The maximum number of decoded items that each thread holds </td></tr>
    <tr><td class="paramname">DecodedOffsetT</td><td>Type used to index into the block's decoded items (large enough to hold the sum over all the runs' lengths) </td></tr>
    <tr><td class="paramname">BLOCK_DIM_Y</td><td>The thread block length in threads along the Y dimension </td></tr>
    <tr><td class="paramname">BLOCK_DIM_Z</td><td>The thread block length in threads along the Z dimension </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcub_1_1_block_run_length_decode_1_1_temp_storage.html">TempStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Methods</h2></td></tr>
<tr class="memitem:a49f08d8e951bb98e6e40175c4e991c0e"><td class="memTemplParams" colspan="2">template&lt;typename RunLengthT , typename TotalDecodedSizeT &gt; </td></tr>
<tr class="memitem:a49f08d8e951bb98e6e40175c4e991c0e"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_run_length_decode.html#a49f08d8e951bb98e6e40175c4e991c0e">BlockRunLengthDecode</a> (<a class="el" href="structcub_1_1_block_run_length_decode_1_1_temp_storage.html">TempStorage</a> &amp;temp_storage, ItemT(&amp;run_values)[RUNS_PER_THREAD], RunLengthT(&amp;run_lengths)[RUNS_PER_THREAD], TotalDecodedSizeT &amp;total_decoded_size)</td></tr>
<tr class="memdesc:a49f08d8e951bb98e6e40175c4e991c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor specialised for user-provided temporary storage, initializing using the runs' lengths. The algorithm's temporary storage may not be repurposed between the constructor call and subsequent <b>RunLengthDecode</b> calls.  <a href="#a49f08d8e951bb98e6e40175c4e991c0e">More...</a><br/></td></tr>
<tr class="separator:a49f08d8e951bb98e6e40175c4e991c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fe15a9be65ff1f6495501b834ee658"><td class="memTemplParams" colspan="2">template&lt;typename UserRunOffsetT &gt; </td></tr>
<tr class="memitem:a14fe15a9be65ff1f6495501b834ee658"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_run_length_decode.html#a14fe15a9be65ff1f6495501b834ee658">BlockRunLengthDecode</a> (<a class="el" href="structcub_1_1_block_run_length_decode_1_1_temp_storage.html">TempStorage</a> &amp;temp_storage, ItemT(&amp;run_values)[RUNS_PER_THREAD], UserRunOffsetT(&amp;run_offsets)[RUNS_PER_THREAD])</td></tr>
<tr class="memdesc:a14fe15a9be65ff1f6495501b834ee658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor specialised for user-provided temporary storage, initializing using the runs' offsets. The algorithm's temporary storage may not be repurposed between the constructor call and subsequent <b>RunLengthDecode</b> calls.  <a href="#a14fe15a9be65ff1f6495501b834ee658">More...</a><br/></td></tr>
<tr class="separator:a14fe15a9be65ff1f6495501b834ee658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f77b873af96cd6c9ea976dba7c44393"><td class="memTemplParams" colspan="2">template&lt;typename RunLengthT , typename TotalDecodedSizeT &gt; </td></tr>
<tr class="memitem:a0f77b873af96cd6c9ea976dba7c44393"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_run_length_decode.html#a0f77b873af96cd6c9ea976dba7c44393">BlockRunLengthDecode</a> (ItemT(&amp;run_values)[RUNS_PER_THREAD], RunLengthT(&amp;run_lengths)[RUNS_PER_THREAD], TotalDecodedSizeT &amp;total_decoded_size)</td></tr>
<tr class="memdesc:a0f77b873af96cd6c9ea976dba7c44393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor specialised for static temporary storage, initializing using the runs' lengths.  <a href="#a0f77b873af96cd6c9ea976dba7c44393">More...</a><br/></td></tr>
<tr class="separator:a0f77b873af96cd6c9ea976dba7c44393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f5bd86566384ec2747ca10a3eef5a7"><td class="memTemplParams" colspan="2">template&lt;typename UserRunOffsetT &gt; </td></tr>
<tr class="memitem:a16f5bd86566384ec2747ca10a3eef5a7"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_run_length_decode.html#a16f5bd86566384ec2747ca10a3eef5a7">BlockRunLengthDecode</a> (ItemT(&amp;run_values)[RUNS_PER_THREAD], UserRunOffsetT(&amp;run_offsets)[RUNS_PER_THREAD])</td></tr>
<tr class="memdesc:a16f5bd86566384ec2747ca10a3eef5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor specialised for static temporary storage, initializing using the runs' offsets.  <a href="#a16f5bd86566384ec2747ca10a3eef5a7">More...</a><br/></td></tr>
<tr class="separator:a16f5bd86566384ec2747ca10a3eef5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2682df94aab75364752f3bd6a4ddf45f"><td class="memTemplParams" colspan="2">template&lt;typename RelativeOffsetT &gt; </td></tr>
<tr class="memitem:a2682df94aab75364752f3bd6a4ddf45f"><td class="memTemplItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_run_length_decode.html#a2682df94aab75364752f3bd6a4ddf45f">RunLengthDecode</a> (ItemT(&amp;decoded_items)[DECODED_ITEMS_PER_THREAD], RelativeOffsetT(&amp;item_offsets)[DECODED_ITEMS_PER_THREAD], DecodedOffsetT from_decoded_offset=0)</td></tr>
<tr class="memdesc:a2682df94aab75364752f3bd6a4ddf45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-length decodes the runs previously passed via a call to Init(...) and returns the run-length decoded items in a blocked arrangement to <code>decoded_items</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> the number of run-length decoded items exceeds the run-length decode buffer (i.e., <b>DECODED_ITEMS_PER_THREAD * BLOCK_THREADS</b>), only the items that fit within the buffer are returned. Subsequent calls to <b>RunLengthDecode</b> adjusting <code>from_decoded_offset</code> can be used to retrieve the remaining run-length decoded items. Calling __syncthreads() between any two calls to <b>RunLengthDecode</b> is not required. <code>item_offsets</code> can be used to retrieve each run-length decoded item's relative index within its run. E.g., the run-length encoded array of <code>3, 1, 4</code> with the respective run lengths of <code>2, 1, 3</code> would yield the run-length decoded array of <code>3, 3, 1, 4, 4, 4</code> with the relative offsets of <code>0, 1, 0, 0, 1, 2</code>. A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed.  <a href="#a2682df94aab75364752f3bd6a4ddf45f">More...</a><br/></td></tr>
<tr class="separator:a2682df94aab75364752f3bd6a4ddf45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb4f47c48435bf3a97875bc85c4259"><td class="memItemLeft" align="right" valign="top">__device__ __forceinline__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcub_1_1_block_run_length_decode.html#a70cb4f47c48435bf3a97875bc85c4259">RunLengthDecode</a> (ItemT(&amp;decoded_items)[DECODED_ITEMS_PER_THREAD], DecodedOffsetT from_decoded_offset=0)</td></tr>
<tr class="memdesc:a70cb4f47c48435bf3a97875bc85c4259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run-length decodes the runs previously passed via a call to Init(...) and returns the run-length decoded items in a blocked arrangement to <code>decoded_items</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> the number of run-length decoded items exceeds the run-length decode buffer (i.e., <b>DECODED_ITEMS_PER_THREAD * BLOCK_THREADS</b>), only the items that fit within the buffer are returned. Subsequent calls to <b>RunLengthDecode</b> adjusting <code>from_decoded_offset</code> can be used to retrieve the remaining run-length decoded items. Calling __syncthreads() between any two calls to <b>RunLengthDecode</b> is not required.  <a href="#a70cb4f47c48435bf3a97875bc85c4259">More...</a><br/></td></tr>
<tr class="separator:a70cb4f47c48435bf3a97875bc85c4259"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a49f08d8e951bb98e6e40175c4e991c0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItemT , int BLOCK_DIM_X, int RUNS_PER_THREAD, int DECODED_ITEMS_PER_THREAD, typename DecodedOffsetT  = uint32_t, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1&gt; </div>
<div class="memtemplate">
template&lt;typename RunLengthT , typename TotalDecodedSizeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_block_run_length_decode.html">cub::BlockRunLengthDecode</a>&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;::<a class="el" href="classcub_1_1_block_run_length_decode.html">BlockRunLengthDecode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcub_1_1_block_run_length_decode_1_1_temp_storage.html">TempStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItemT(&amp;)&#160;</td>
          <td class="paramname"><em>run_values</em>[RUNS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RunLengthT(&amp;)&#160;</td>
          <td class="paramname"><em>run_lengths</em>[RUNS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TotalDecodedSizeT &amp;&#160;</td>
          <td class="paramname"><em>total_decoded_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor specialised for user-provided temporary storage, initializing using the runs' lengths. The algorithm's temporary storage may not be repurposed between the constructor call and subsequent <b>RunLengthDecode</b> calls. </p>

</div>
</div>
<a class="anchor" id="a14fe15a9be65ff1f6495501b834ee658"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItemT , int BLOCK_DIM_X, int RUNS_PER_THREAD, int DECODED_ITEMS_PER_THREAD, typename DecodedOffsetT  = uint32_t, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1&gt; </div>
<div class="memtemplate">
template&lt;typename UserRunOffsetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_block_run_length_decode.html">cub::BlockRunLengthDecode</a>&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;::<a class="el" href="classcub_1_1_block_run_length_decode.html">BlockRunLengthDecode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcub_1_1_block_run_length_decode_1_1_temp_storage.html">TempStorage</a> &amp;&#160;</td>
          <td class="paramname"><em>temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItemT(&amp;)&#160;</td>
          <td class="paramname"><em>run_values</em>[RUNS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UserRunOffsetT(&amp;)&#160;</td>
          <td class="paramname"><em>run_offsets</em>[RUNS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor specialised for user-provided temporary storage, initializing using the runs' offsets. The algorithm's temporary storage may not be repurposed between the constructor call and subsequent <b>RunLengthDecode</b> calls. </p>

</div>
</div>
<a class="anchor" id="a0f77b873af96cd6c9ea976dba7c44393"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItemT , int BLOCK_DIM_X, int RUNS_PER_THREAD, int DECODED_ITEMS_PER_THREAD, typename DecodedOffsetT  = uint32_t, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1&gt; </div>
<div class="memtemplate">
template&lt;typename RunLengthT , typename TotalDecodedSizeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_block_run_length_decode.html">cub::BlockRunLengthDecode</a>&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;::<a class="el" href="classcub_1_1_block_run_length_decode.html">BlockRunLengthDecode</a> </td>
          <td>(</td>
          <td class="paramtype">ItemT(&amp;)&#160;</td>
          <td class="paramname"><em>run_values</em>[RUNS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RunLengthT(&amp;)&#160;</td>
          <td class="paramname"><em>run_lengths</em>[RUNS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TotalDecodedSizeT &amp;&#160;</td>
          <td class="paramname"><em>total_decoded_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor specialised for static temporary storage, initializing using the runs' lengths. </p>

</div>
</div>
<a class="anchor" id="a16f5bd86566384ec2747ca10a3eef5a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItemT , int BLOCK_DIM_X, int RUNS_PER_THREAD, int DECODED_ITEMS_PER_THREAD, typename DecodedOffsetT  = uint32_t, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1&gt; </div>
<div class="memtemplate">
template&lt;typename UserRunOffsetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ <a class="el" href="classcub_1_1_block_run_length_decode.html">cub::BlockRunLengthDecode</a>&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;::<a class="el" href="classcub_1_1_block_run_length_decode.html">BlockRunLengthDecode</a> </td>
          <td>(</td>
          <td class="paramtype">ItemT(&amp;)&#160;</td>
          <td class="paramname"><em>run_values</em>[RUNS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UserRunOffsetT(&amp;)&#160;</td>
          <td class="paramname"><em>run_offsets</em>[RUNS_PER_THREAD]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor specialised for static temporary storage, initializing using the runs' offsets. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2682df94aab75364752f3bd6a4ddf45f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItemT , int BLOCK_DIM_X, int RUNS_PER_THREAD, int DECODED_ITEMS_PER_THREAD, typename DecodedOffsetT  = uint32_t, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1&gt; </div>
<div class="memtemplate">
template&lt;typename RelativeOffsetT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_block_run_length_decode.html">cub::BlockRunLengthDecode</a>&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;::RunLengthDecode </td>
          <td>(</td>
          <td class="paramtype">ItemT(&amp;)&#160;</td>
          <td class="paramname"><em>decoded_items</em>[DECODED_ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RelativeOffsetT(&amp;)&#160;</td>
          <td class="paramname"><em>item_offsets</em>[DECODED_ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecodedOffsetT&#160;</td>
          <td class="paramname"><em>from_decoded_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run-length decodes the runs previously passed via a call to Init(...) and returns the run-length decoded items in a blocked arrangement to <code>decoded_items</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> the number of run-length decoded items exceeds the run-length decode buffer (i.e., <b>DECODED_ITEMS_PER_THREAD * BLOCK_THREADS</b>), only the items that fit within the buffer are returned. Subsequent calls to <b>RunLengthDecode</b> adjusting <code>from_decoded_offset</code> can be used to retrieve the remaining run-length decoded items. Calling __syncthreads() between any two calls to <b>RunLengthDecode</b> is not required. <code>item_offsets</code> can be used to retrieve each run-length decoded item's relative index within its run. E.g., the run-length encoded array of <code>3, 1, 4</code> with the respective run lengths of <code>2, 1, 3</code> would yield the run-length decoded array of <code>3, 3, 1, 4, 4, 4</code> with the relative offsets of <code>0, 1, 0, 0, 1, 2</code>. A subsequent <code>__syncthreads()</code> threadblock barrier should be invoked after calling this method if the collective's temporary storage (e.g., <code>temp_storage</code>) is to be reused or repurposed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">decoded_items</td><td>The run-length decoded items to be returned in a blocked arrangement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">item_offsets</td><td>The run-length decoded items' relative offset within the run they belong to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_decoded_offset</td><td><a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> invoked with from_decoded_offset that is larger than total_decoded_size results in undefined behavior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70cb4f47c48435bf3a97875bc85c4259"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItemT , int BLOCK_DIM_X, int RUNS_PER_THREAD, int DECODED_ITEMS_PER_THREAD, typename DecodedOffsetT  = uint32_t, int BLOCK_DIM_Y = 1, int BLOCK_DIM_Z = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ __forceinline__ void <a class="el" href="classcub_1_1_block_run_length_decode.html">cub::BlockRunLengthDecode</a>&lt; ItemT, BLOCK_DIM_X, RUNS_PER_THREAD, DECODED_ITEMS_PER_THREAD, DecodedOffsetT, BLOCK_DIM_Y, BLOCK_DIM_Z &gt;::RunLengthDecode </td>
          <td>(</td>
          <td class="paramtype">ItemT(&amp;)&#160;</td>
          <td class="paramname"><em>decoded_items</em>[DECODED_ITEMS_PER_THREAD], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DecodedOffsetT&#160;</td>
          <td class="paramname"><em>from_decoded_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run-length decodes the runs previously passed via a call to Init(...) and returns the run-length decoded items in a blocked arrangement to <code>decoded_items</code>. <a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> the number of run-length decoded items exceeds the run-length decode buffer (i.e., <b>DECODED_ITEMS_PER_THREAD * BLOCK_THREADS</b>), only the items that fit within the buffer are returned. Subsequent calls to <b>RunLengthDecode</b> adjusting <code>from_decoded_offset</code> can be used to retrieve the remaining run-length decoded items. Calling __syncthreads() between any two calls to <b>RunLengthDecode</b> is not required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">decoded_items</td><td>The run-length decoded items to be returned in a blocked arrangement </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from_decoded_offset</td><td><a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> invoked with from_decoded_offset that is larger than total_decoded_size results in undefined behavior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="block__run__length__decode_8cuh.html">block_run_length_decode.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2022 NVIDIA Corporation
</small></address>
</body>
</html>
