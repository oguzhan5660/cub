<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: cub::DeviceRadixSort Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   &#160;<!--span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cub</b></li><li class="navelem"><a class="el" href="structcub_1_1_device_radix_sort.html">DeviceRadixSort</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="structcub_1_1_device_radix_sort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::DeviceRadixSort Struct Reference<div class="ingroups"><a class="el" href="group___single_module.html">Single-problem</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><p><a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> provides device-wide, parallel operations for computing a radix sort across a sequence of data items residing within device-accessible memory. </p>
<div class="image">
<img src="sorting_logo.png" alt="sorting_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>The <a href="http://en.wikipedia.org/wiki/Radix_sort"><em>radix sorting method</em></a> arranges items into ascending (or descending) order. The algorithm relies upon a positional representation for keys, i.e., each key is comprised of an ordered sequence of symbols (e.g., digits, characters, etc.) specified from least-significant to most-significant. For a given input sequence of keys and a set of rules specifying a total ordering of the symbolic alphabet, the radix sorting method produces a lexicographic ordering of those keys.</dd></dl>
<dl class="section user"><dt>Supported Types</dt><dd><a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> can sort all of the built-in C++ numeric primitive types (<code>unsigned char</code>, <code>int</code>, <code>double</code>, etc.) as well as CUDA's <code>__half</code> and <code>__nv_bfloat16</code> 16-bit floating-point types.</dd></dl>
<dl class="section user"><dt>Floating-Point Special Cases</dt><dd><ul>
<li>Positive and negative zeros are considered equivalent, and will be treated as such in the output.</li>
<li>No special handling is implemented for NaN values; these are sorted according to their bit representations after any transformations.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Transformations</dt><dd>Although the direct radix sorting method can only be applied to unsigned integral types, <a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> is able to sort signed and floating-point types via simple bit-wise transformations that ensure lexicographic key ordering. Additional transformations occur for descending sorts. These transformations must be considered when restricting the <code>[begin_bit, end_bit)</code> range, as the bitwise transformations will occur before the bit-range truncation.</dd></dl>
<p>Any transformations applied to the keys prior to sorting are reversed while writing to the final output buffer.</p>
<dl class="section user"><dt>Type Specific Bitwise Transformations</dt><dd>To convert the input values into a radix-sortable bitwise representation, the following transformations take place prior to sorting:<ul>
<li>For unsigned integral values, the keys are used directly.</li>
<li>For signed integral values, the sign bit is inverted.</li>
<li>For positive floating point values, the sign bit is inverted.</li>
<li>For negative floating point values, the full key is inverted.</li>
</ul>
</dd></dl>
<p>For floating point types, positive and negative zero are a special case and will be considered equivalent during sorting.</p>
<dl class="section user"><dt>Descending Sort Bitwise Transformations</dt><dd><a class="el" href="struct_if.html" title="Type selection (IF ? ThenType : ElseType) ">If</a> descending sort is used, the keys are inverted after performing any type-specific transformations, and the resulting keys are sorted in ascending order.</dd></dl>
<dl class="section user"><dt>Stability</dt><dd><a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> is stable. For floating-point types, -0.0 and +0.0 are considered equal and appear in the result in the same order as they appear in the input.</dd></dl>
<dl class="section user"><dt>Usage Considerations</dt><dd><ul>
<li><em>Dynamic parallelism</em>. <a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> methods can be called within kernel code on devices in which CUDA dynamic parallelism is supported.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The work-complexity of radix sort as a function of input size is linear, resulting in performance throughput that plateaus with problem sizes large enough to saturate the GPU. The following chart illustrates <a class="el" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortKeys</a> performance across different CUDA architectures for uniform-random <code>uint32</code> keys. Performance plots for other scenarios can be found in the detailed method descriptions below.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_keys.png" alt="lsb_radix_sort_int32_keys.png"/>
</div>
 </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">KeyT-value pairs</div></td></tr>
<tr class="memitem:a65e82152de448c6373ed9563aaf8af7e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:a65e82152de448c6373ed9563aaf8af7e"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e">SortPairs</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a65e82152de448c6373ed9563aaf8af7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into ascending order. (~<em>2N </em>auxiliary storage required)  <a href="#a65e82152de448c6373ed9563aaf8af7e">More...</a><br/></td></tr>
<tr class="separator:a65e82152de448c6373ed9563aaf8af7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559ec1faaf5dbfa663544942f72abfb3"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:a559ec1faaf5dbfa663544942f72abfb3"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a559ec1faaf5dbfa663544942f72abfb3">SortPairs</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a559ec1faaf5dbfa663544942f72abfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into ascending order. (~<em>N </em>auxiliary storage required)  <a href="#a559ec1faaf5dbfa663544942f72abfb3">More...</a><br/></td></tr>
<tr class="separator:a559ec1faaf5dbfa663544942f72abfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496376ec17c2f5e191b60e2a1987ed64"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:a496376ec17c2f5e191b60e2a1987ed64"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a496376ec17c2f5e191b60e2a1987ed64">SortPairsDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, const ValueT *d_values_in, ValueT *d_values_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a496376ec17c2f5e191b60e2a1987ed64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into descending order. (~<em>2N</em> auxiliary storage required).  <a href="#a496376ec17c2f5e191b60e2a1987ed64">More...</a><br/></td></tr>
<tr class="separator:a496376ec17c2f5e191b60e2a1987ed64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086cba1fb996273075eb1991c2b7548e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:a086cba1fb996273075eb1991c2b7548e"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a086cba1fb996273075eb1991c2b7548e">SortPairsDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a086cba1fb996273075eb1991c2b7548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into descending order. (~<em>N </em>auxiliary storage required).  <a href="#a086cba1fb996273075eb1991c2b7548e">More...</a><br/></td></tr>
<tr class="separator:a086cba1fb996273075eb1991c2b7548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Keys-only</div></td></tr>
<tr class="memitem:aa1a9285615b804d83358d3ee8c5d5a60"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:aa1a9285615b804d83358d3ee8c5d5a60"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60">SortKeys</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:aa1a9285615b804d83358d3ee8c5d5a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into ascending order. (~<em>2N </em>auxiliary storage required)  <a href="#aa1a9285615b804d83358d3ee8c5d5a60">More...</a><br/></td></tr>
<tr class="separator:aa1a9285615b804d83358d3ee8c5d5a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd81eb0c356fb87908cccf33b621238d"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:abd81eb0c356fb87908cccf33b621238d"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#abd81eb0c356fb87908cccf33b621238d">SortKeys</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:abd81eb0c356fb87908cccf33b621238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into ascending order. (~<em>N </em>auxiliary storage required).  <a href="#abd81eb0c356fb87908cccf33b621238d">More...</a><br/></td></tr>
<tr class="separator:abd81eb0c356fb87908cccf33b621238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae37ceda993c0446b197a53713225b"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:a9dae37ceda993c0446b197a53713225b"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a9dae37ceda993c0446b197a53713225b">SortKeysDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, const KeyT *d_keys_in, KeyT *d_keys_out, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a9dae37ceda993c0446b197a53713225b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into descending order. (~<em>2N</em> auxiliary storage required).  <a href="#a9dae37ceda993c0446b197a53713225b">More...</a><br/></td></tr>
<tr class="separator:a9dae37ceda993c0446b197a53713225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac900f538b1f13d8b92f7b4f4ae0903d8"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename NumItemsT &gt; </td></tr>
<tr class="memitem:ac900f538b1f13d8b92f7b4f4ae0903d8"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#ac900f538b1f13d8b92f7b4f4ae0903d8">SortKeysDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, NumItemsT num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ac900f538b1f13d8b92f7b4f4ae0903d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into descending order. (~<em>N </em>auxiliary storage required).  <a href="#ac900f538b1f13d8b92f7b4f4ae0903d8">More...</a><br/></td></tr>
<tr class="separator:ac900f538b1f13d8b92f7b4f4ae0903d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a65e82152de448c6373ed9563aaf8af7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into ascending order. (~<em>2N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>Pointers to contiguous memory must be used; iterators are not currently supported.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys_in, d_keys_in + num_items)</code></li>
<li><code>[d_keys_out, d_keys_out + num_items)</code></li>
<li><code>[d_values_in, d_values_in + num_items)</code></li>
<li><code>[d_values_out, d_values_out + num_items)</code></li>
</ul>
</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32,uint32</code> and <code>uint64,uint64</code> pairs, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_pairs.png" alt="lsb_radix_sort_int32_pairs.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_pairs.png" alt="lsb_radix_sort_int64_pairs.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Pointer to the corresponding input sequence of associated value items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Pointer to the correspondingly-reordered output sequence of associated value items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_device_radix_sort_8cu-example.html#a2">example_device_radix_sort.cu</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a559ec1faaf5dbfa663544942f72abfb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into ascending order. (~<em>N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys.Current(), d_keys.Current() + num_items)</code></li>
<li><code>[d_keys.Alternate(), d_keys.Alternate() + num_items)</code></li>
<li><code>[d_values.Current(), d_values.Current() + num_items)</code></li>
<li><code>[d_values.Alternate(), d_values.Alternate() + num_items)</code></li>
</ul>
</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32,uint32</code> and <code>uint64,uint64</code> pairs, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_pairs.png" alt="lsb_radix_sort_int32_pairs.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_pairs.png" alt="lsb_radix_sort_int64_pairs.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a496376ec17c2f5e191b60e2a1987ed64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into descending order. (~<em>2N</em> auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>Pointers to contiguous memory must be used; iterators are not currently supported.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys_in, d_keys_in + num_items)</code></li>
<li><code>[d_keys_out, d_keys_out + num_items)</code></li>
<li><code>[d_values_in, d_values_in + num_items)</code></li>
<li><code>[d_values_out, d_values_out + num_items)</code></li>
</ul>
</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortPairs</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a496376ec17c2f5e191b60e2a1987ed64" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a496376ec17c2f5e191b60e2a1987ed64" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [9, 8, 7, 6, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [6, 0, 2, 1, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Pointer to the corresponding input sequence of associated value items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Pointer to the correspondingly-reordered output sequence of associated value items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a086cba1fb996273075eb1991c2b7548e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into descending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys.Current(), d_keys.Current() + num_items)</code></li>
<li><code>[d_keys.Alternate(), d_keys.Alternate() + num_items)</code></li>
<li><code>[d_values.Current(), d_values.Current() + num_items)</code></li>
<li><code>[d_values.Alternate(), d_values.Alternate() + num_items)</code></li>
</ul>
</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#a65e82152de448c6373ed9563aaf8af7e" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortPairs</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a496376ec17c2f5e191b60e2a1987ed64" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a496376ec17c2f5e191b60e2a1987ed64" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [9, 8, 7, 6, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [6, 0, 2, 1, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1a9285615b804d83358d3ee8c5d5a60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into ascending order. (~<em>2N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>Pointers to contiguous memory must be used; iterators are not currently supported.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys_in, d_keys_in + num_items)</code></li>
<li><code>[d_keys_out, d_keys_out + num_items)</code></li>
</ul>
</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32</code> and <code>uint64</code> keys, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_keys.png" alt="lsb_radix_sort_int32_keys.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_keys.png" alt="lsb_radix_sort_int64_keys.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd81eb0c356fb87908cccf33b621238d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into ascending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys.Current(), d_keys.Current() + num_items)</code></li>
<li><code>[d_keys.Alternate(), d_keys.Alternate() + num_items)</code></li>
</ul>
</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32</code> and <code>uint64</code> keys, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_keys.png" alt="lsb_radix_sort_int32_keys.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_keys.png" alt="lsb_radix_sort_int64_keys.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dae37ceda993c0446b197a53713225b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into descending order. (~<em>2N</em> auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation.</li>
<li>Pointers to contiguous memory must be used; iterators are not currently supported.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys_in, d_keys_in + num_items)</code></li>
<li><code>[d_keys_out, d_keys_out + num_items)</code></li>
</ul>
</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortKeys</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a9dae37ceda993c0446b197a53713225b" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a9dae37ceda993c0446b197a53713225b" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [9, 8, 7, 6, 5, 3, 0]s</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac900f538b1f13d8b92f7b4f4ae0903d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename NumItemsT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumItemsT&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into descending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>In-place operations are not supported. There must be no overlap between any of the provided ranges:<ul>
<li><code>[d_keys.Current(), d_keys.Current() + num_items)</code></li>
<li><code>[d_keys.Alternate(), d_keys.Alternate() + num_items)</code></li>
</ul>
</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#aa1a9285615b804d83358d3ee8c5d5a60" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortKeys</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a9dae37ceda993c0446b197a53713225b" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a9dae37ceda993c0446b197a53713225b" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [9, 8, 7, 6, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">NumItemsT</td><td><b>[inferred]</b> Type of num_items </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="device__radix__sort_8cuh.html">device_radix_sort.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2022 NVIDIA Corporation
</small></address>
</body>
</html>
